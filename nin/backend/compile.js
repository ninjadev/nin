const chalk = require('chalk');
const glob = require('glob');
const closureCompiler = require('google-closure-compiler-js');
const compress = require('./compress').compress;
const fs = require('fs-promise');
const OptiPng = require('optipng');
const p = require('path');
const projectSettings = require('./projectSettings');
const shaderGen = require('./shadergen');
const stream = require('stream');
const utils = require('./utils');
const dasbootGen = require('./dasbootgen');
const fontGen = require('./fontgen');
const walk = require('walk');


function moveCursorToColumn(col) {
  return '\x1B[' + col + 'G';
}

function renderOK() {
  console.log(moveCursorToColumn(72) +
    chalk.grey('[') + chalk.green('✔️ OK') + chalk.grey(']'));
}

function renderWarn() {
  console.log(moveCursorToColumn(70) +
    chalk.grey('[') + chalk.yellow('⚠️ WARN') + chalk.grey(']'));
}

function renderError() {
  console.log(moveCursorToColumn(69) +
    chalk.grey('[') + chalk.red('❌ ERROR') + chalk.grey(']'));
}

async function res(projectPath, options) {
  const walker = walk.walk(projectPath + '/res/' , {followLinks: false});
  const files = [];
  console.log(chalk.yellow('\nCollecting files from res/'));
  walker.on('file', async function(root, stat, next) {

    /* hacks to ensure slashes in path are correct.
     * TODO: is there a bug in walker that causes
     * these things to happen?  */
    root += '/';
    root = root.replace(/\/\//g, '/');

    const filename = root + stat.name;
    const file = await fs.readFile(filename);
    if(p.extname(filename) == '.otf') {
      process.stdout.write('- Skipping ' + chalk.grey(root.slice(projectPath.length + 1)) + chalk.magenta(stat.name) + chalk.grey(', (it is a font)'));
      renderOK();
      next();
      return;
    }
    process.stdout.write('- Assimilating ' + chalk.grey(root.slice(projectPath.length + 1)) + chalk.magenta(stat.name));
    function pushFinishedFile(file) {
      files.push('FILES[\'' + root.slice(projectPath.length + 1) + stat.name + '\']=\'' +
        file.toString('base64') + '\'');
      renderOK();
      next();
    }
    if(options.optimizePngAssets && stat.name.slice(-4).toLowerCase() == '.png') {
      const chunks = [];
      const s = new stream.Readable();
      s.push(file);
      s.push(null);

      const pngOptimizer = new OptiPng(['-o7']);
      s.pipe(pngOptimizer).on('data', data => {
        chunks.push(data);
      }).on('end', () => {
        const newFile = Buffer.concat(chunks);
        const percentage = (((file.length / newFile.length - 1) * 10000) | 0) / 100;
        process.stdout.write(
            '\n    OptiPng: saved ' +
            chalk.cyan(`${(file.length - newFile.length) / 1024 | 0}KB`) +
            ' (' +
            chalk.green(`${percentage}%`) + ' reduction)');
        pushFinishedFile(newFile);
      });
    } else {
      pushFinishedFile(file);
    }
  });
  return new Promise(resolve => {
    walker.on('end', function(){
      process.stdout.write(chalk.yellow('\nMerging assimilated files'));
      resolve('FILES={};' + files.join(';') + ';');
      renderOK();
    });
  });
}

async function collect(projectPath, data) {
  const {
    projectSettings,
    projectVersion,
    projectOrigin,
  } = utils.getProjectMetadata(projectPath);

  const ninMeta = utils.getNinMetadata();

  const metadata = {
    'Title': projectSettings.title,
    'Author': projectSettings.authors.join(', '),
    'Description': projectSettings.description,
    'Creation time': '' + new Date(),
    'Software': `${projectVersion} @ ${projectOrigin}\n${ninMeta.name}@${ninMeta.version} from ${ninMeta.origin}`,
    previewImage: projectSettings.previewImage
  };

  const metadataAsHTMLComments = Object.keys(metadata)
    .map(key => `<!-- ${key}: ${metadata[key]} -->`)
    .join('\n');

  const ogTags =
    `<meta property="og:title" content="${utils.unsafeHTMLEscape(metadata.Title)}" />
    <meta property="og:description" content="${utils.unsafeHTMLEscape(metadata.Description)}" />
    <meta property="og:image" content="${metadata.previewImage}" />
    <meta name="author" content="${utils.unsafeHTMLEscape(metadata.Author)}" />`;

  const htmlPreamble =
    fs.readFileSync(projectPath + '/index.html', {encoding: 'utf8'})
    .replace(
      'NIN_WILL_REPLACE_THIS_TAG_WITH_YOUR_ANALYTICS_ID',
      projectSettings.googleAnalyticsID)
    .replace(
      'NIN_WILL_REPLACE_THIS_TAG_WITH_AUTOGENERATED_COMMENT_TAGS',
      metadataAsHTMLComments)
    .replace(
      'NIN_WILL_REPLACE_THIS_TAG_WITH_AUTOGENERATED_META_TAGS',
      ogTags);

  const html =
    htmlPreamble +
    '<script>' +
    'GU=1;' + /* hack to make sure GU exisits from the get-go */
    'BEAN=0;' +
    'BEAT=false;' +
    data +
    'var graph = JSON.parse(atob(FILES["res/graph.json"]));' +
    'demo=bootstrap({graph:graph, onprogress: ONPROGRESS, oncomplete: ONCOMPLETE});' +
    '</script>';
  await fs.outputFile(p.join(projectPath, 'bin', 'demo.html'), html);
  process.stdout.write('Successfully compiled demo.html!\n');

  process.stdout.write(chalk.yellow('\nCompressing demo to .png.html'));

  const compressed = await compress(projectPath, data, htmlPreamble, metadata);
  renderOK();
  await fs.outputFile(p.join(projectPath, 'bin', 'demo.png.html'), compressed);
  console.log(chalk.white('\n★ ---------------------------------------- ★'));
  console.log(chalk.white('| ') +
    chalk.green('Successfully compiled ') +
      chalk.grey('bin/') +
      chalk.green('demo.png.html!') +
      chalk.white(' |'));
  console.log(chalk.white('★ ---------------------------------------- ★\n'));
}

const compile = async function(projectPath, options) {
  const genPath = p.join(projectPath, '/gen/');
  await fs.remove(genPath);

  const data = await res(projectPath, options);
  await fs.outputFile(p.join(genPath, 'files.js'), data);

  projectSettings.generate(projectPath);

  shaderGen(projectPath, async function() {
    await Promise.all([
      fontGen(projectPath),
      dasbootGen(projectPath),
    ]);

    const globPaths = [
      projectPath + '/gen/*.js ',
      projectPath + '/lib/*.js ',
      projectPath + '/src/*.js',
    ];
    const jsCode = [].concat.apply(
      [], globPaths.map(globPath => glob.sync(globPath)))
      .map(path => ({
        src: fs.readFileSync(path, 'utf8'),
        path
      }));
    if (!options.closureCompiler) {
      process.stdout.write(chalk.yellow('\nConcatenating source files'));
      const sources = jsCode.map(file => file.src).join(';');
      renderOK();
      await collect(projectPath, sources);
    } else {
      process.stdout.write(chalk.yellow('\nRunning closure compiler'));
      const out = closureCompiler.compile({jsCode});
      if(out.errors.length) {
        renderError();
        out.errors.map(console.error);
        process.exit(1);
      } else if(out.warnings.length) {
        renderWarn();
        out.warnings.map(console.error);
      } else {
        renderOK();
      }
      await collect(projectPath, out.compiledCode);
    }
  }, true);
};


module.exports = {compile: compile};
